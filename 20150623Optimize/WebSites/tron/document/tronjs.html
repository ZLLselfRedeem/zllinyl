<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>TronJS 最好的前端模块加载器</title>

    <!-- Bootstrap -->
    <link href="bootstrap/css/bootstrap.css" rel="stylesheet">
    <link href="bootstrap/css/font-awesome.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="http://cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="http://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>
  <style>
  	*{font-family:'microsoft yahei',Arial, Helvetica, sans-serif; outline:none;}
  	h1{ border-bottom:1px solid #eee; padding-bottom:10px; margin-bottom:0px;}
	.title{ padding:17px 10px; border-bottom:1px solid #eee; background-color:#f9f9f9;}
	section{ margin-bottom:30px;}
	h2{ margin-bottom:15px;}
	h4 i.fa{ color:#3C3; text-shadow:1px 1px 1px rgba(0,0,0,.2);}
	li strong{ font-weight:normal; color:#09F}
	li{ color:#666;}
	li.L0, li.L1, li.L2, li.L3,li.L5, li.L6, li.L7, li.L8{ list-style-type: decimal !important }
  </style>
  <body>
  	<h1><div class="container">Global TronJS Scripts Loader. <i class="fa fa-html5"></i></div></h1>
    <div class="title">
    	<div class="container">
        <a href="https://github.com/cevio/tronjs.js" target="_blank" class="btn btn-info"><i class="fa fa-github-alt"></i> Fork Project On GitHub.</a><span style="margin-left:15px;">QQ群：7267790</span>
        </div>
    </div>
	<div class="container">
        <section>
        	<h2><i class="fa fa-h-square"></i> TronJS简介</h2>
            <p>前端模块化的需求日益剧增，模块之间的关系也变的非常复杂，所以我们提出了模块依赖关系处理机制。TronJS的诞生就是这种机制的产物。在TronJS中，我们采用了非常先进的技术来处理异步请求。在国际上，被称为回调杀手的Promise也被引入到该框架。或许你们会问，Promise对低端IE不兼容。是的。但是我已经将<code>es6-promise</code>模块加载进了框架，也就意味着，使用我的框架，将能在所有浏览器使用Promise，这是对开发者极大的支持。不仅如此，我们也对JS没有类方法的缺陷进行了补足。在TronJS中，我们存在<code>new Class();</code>的方法来为对象产生一个实体类。类可以进行扩展和继承，这个说明请在之后的详细介绍中查看。</p>
            <p><strong>优势：</strong>我们可以自由配置模块的依赖关系，并且在加载模块的同时，悠先递归加载依赖模块。更可喜的是，在模块依赖关系中我们可以对单独一个队列的模块进行AMD或者CMD方式进行加载。保证模块加载顺序和速度。</p>
            <p><strong>劣势：</strong>使用TronJS加载模块，页面中可能会出现较多的请求链接，这会滞缓模块加载速度。但是，对于普通的项目，已经绰绰有余，基本不是问题。但是对于大型项目，我希望通过合并打包的方式加载模块。</p>
            <p>总之，利弊取舍还需要大家自己掂量。同类型加载库还有 <a href="http://seajs.org" target="_blank">sea.js</a> <a href="http://requirejs.org" target="_blank">Require.js</a>等等。</p>
            <p>以上所有加载器都遵循国际<a href="http://www.commonjs.org" target="_blank">Commonjs</a>规范。</p>
        </section>
      	<section>
       		<h2><i class="fa fa-h-square"></i> 开始：引入模块</h2>
          	<p>主体框架引入：<code>&lt;script src=&quot;http://tron.webkits.cn/tron.min.js&quot;&gt;&lt;/script&gt;</code></p>
			<p>需要需要加载一些被映射的插件，那么请使用以下方式：</p>
          	<p><code>&lt;script src=&quot;http://tron.webkits.cn/tron.maps.js&quot;&gt;&lt;/script&gt;</code></p>
            <p>加载完毕后你可以进行代码操作了。比如说需要悠先加载jQuery插件后加载其他插件</p>
            <p><pre>require('jquery')
	.then(function(){
		return require('jquery-plugin-velocity');
	})
	.then(function(){ 
		/* do something else */ 
	});</pre></p>
        </section>
        
        <section>
        	<h2><i class="fa fa-h-square"></i> window.Library 库</h2>
            <p>该函数库用来设置框架的基本参数。主要用到<code>Library.onMap</code>和<code>Library.setBase</code>两个方法。</p>
            <h4><i class="fa fa-code"></i> Library.onMap( ShortName, TargetModule );</h4>
            <ul>
            	<li><strong>ShortName:</strong> 映射成的模块新命名</li>
                <li><strong>TargetModule:</strong> 目标模块的路径选择代码</li>
            </ul>
            <p>如果我们要将<code>jquery-plugins/jquery.mousewheel/jquery.mousewheel.min.js</code>模块映射成为<code>jquery-plugin-mousewheel</code>。那么你可以这样写：</p>
            <p><code>Library.onMap('jquery-plugin-mousewheel', 'jquery-plugins/jquery.mousewheel/jquery.mousewheel.min.js');</code></p>
            
            <h4><i class="fa fa-code"></i> Library.setBase( BaseName );</h4>
            <ul>
            	<li><strong>BaseName:</strong> 框架基址位置</li>
            </ul>
            <p>设置基址的作用是当使用<code>private/a/b</code>这种开头不带符号的选择器的时候，都可以以基址为标准进行加载，而不需要考虑到具体文件所在的路径。当然，你的基址也可以设置成好多级目录或者不设置。如果不设置，是以网站根目录作为基址。</p>
            <p><code>Library.setBase('blog/pjblog');</code></p>
        </section>
        
        <section>
        	<h2><i class="fa fa-h-square"></i> window.Class 类</h2>
            <p>扩展了javascript无法创建类的局限性。可以通过<code>new Class()</code>的方法创建属于自己的类。而且此类与彼类可以互相继承和扩展。下面我们来看下类的操作方法，以便我们更好的使用类方法优化我们的代码和逻辑。</p>
            <ol>
            	<li>
                	<p>创建一个空类来扩展。</p>
                    <pre>var class = new Class();</pre>
                </li>
                <li>
                	<p>创建一个非空类来扩展。</p>
                    <pre>var class = new Class({ a: 1, b: 2 });</pre>
                </li>
                <li>
                	<p>创建一个带继承的新类来扩展。</p>
                    <pre>var a = new Class({a: 1, b: 2}); 
var b = new Class(a, { c: 3, d: 4 });</pre>
                </li>
                <li>
                	<p>扩展类的实例方法。</p>
                    <pre>var class = new Class(); 
class.add('a', 1); 
class.add({ b: 2, c: 3 });</pre>
                </li>
                <li>
                	<p>类与类的自继承。</p>
                    <pre>var a = new Class({a: 1, b: 2}); 
var b = new Class({c: 1, d: 2}); 
a.extend(b);</pre>
                </li>
                <li>
                	<p>新建类的多层继承。</p>
                    <pre>var a = new Class({a: 1, b: 2}); 
var b = new Class({c: 1, d: 2}); 
var c = new Class(); 
c.extend([a, b]); 
c.extend(a).extend(b);</pre>
                </li>
                <li>
                	<p>类的继承后扩展。</p>
                    <pre>var a = new Class({a: 1, b: 2}); 
var b = new Class({c: 1, d: 2}); 
a.extend(b).add('e', 5);</pre>
                </li>
                <li>
                	<p>类的实例化。</p>
                    <pre>var class = new Class({ a: 1, b: 2 }); 
var a = new class(); 
console.log(a.a); // 1</pre>
                </li>
                <li>
                	<p>类的初始化实例方法。(initialize)</p>
                    <pre>var class = new Class({ a: 1, b: 2 }); 
class.add('initialize', function(){ 
	console.log(this.a);  //1
});</pre>
                </li>
            </ol>
            <p>基本使用方法如上。如果你能活用这个类方法，对你的代码的规范性和严谨性有很大的帮助。如果你能深入研究，会发现这个类方法能做的事情还有很多。</p>
        </section>
        
        <section>
        	<h2><i class="fa fa-h-square"></i> window.Promise 标准协议</h2>
            <p>我们引入了ES6-Promise 协议规范，来特别对不支持Promise的浏览器进行兼容。具体使用方法，请参考 <a href="http://github.com/jakearchibald/es6-promise" target="_blank">ES6-Promise/A+</a> , <a href="http://www.zhangxinxu.com/wordpress/2014/02/es6-javascript-promise-%E6%84%9F%E6%80%A7%E8%AE%A4%E7%9F%A5/" target="_blank">ES6 JavaScript Promise的感性认知</a> , <a href="http://www.html5rocks.com/zh/tutorials/es6/promises/" target="_blank">HTML5Rocks Promise</a> , <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank">MDN Promise Develope</a>。</p>
        </section>
        
        <section>
        	<h2><i class="fa fa-h-square"></i> contrast 和 resolve</h2>
            <p>这两个方法都被称为路径选择器方法。作用是通过规则返回文件在线上的绝对地址。这个和后端的TRONASP是通用的。</p>
            <h4><i class="fa fa-code"></i> contrast(selector); resolve(selector);</h4>
            <ul>
                <li><span class="keyword">selector:</span> <span class="keyvalue">路径选择器标识符</span>
            </ul>
            <p>前端开发的同学们都知道，jQuery有种标识符类似 $("a[m='222']") 这种类型来获取节点的集合，组成一个jQuery对象供用户操作。contrast 也差不多，就是通过固定的规则格式来产生完整的绝对路径地址。</p>
            <p>下面我们来看一段后端的代码，就可以明白了。</p>
            <pre>
/*
 * 我们当前文件是： e:\code\pjblog5\action\default.asp
 * 我们的基址： e:\code\pjblog5
 * 网站目录： e:\code\pjblog5
 */ 
 
// 输出：e:\code\pjblog5\a\b\c\d.js
// 基于基址的地址
contrast("a/b/c/d.js");

// 输出：e:\code\pjblog5\a\b\c\d.js
// 基于网站根目录的地址
contrast("/a/b/c/d.js");

// 输出：e:\code\pjblog5\action\a\b\c\d.js
// 基于当前文件的地址
contrast("./a/b/c/d.js");

// 输出：e:\code\pjblog5\a\b\c\d.js
// 基于上级文件夹的地址
contrast("../a/b/c/d.js");
            </pre>
            <p>resolve和contrast唯一的不同是resolve检测文件最后的文件名是否为JS，如果不是，就自动加上<code>.js</code></p>
        </section>
        
        <section>
        	<h2><i class="fa fa-h-square"></i> require 国际 CommonJs 标准协议</h2>
            <p>我们在国际协议基础上增加了对每个require返回一个Promise的修改，让其可以使用<code>.then()</code>的方法进行回调。 Kill Callbacks. 这就是我们想要做的。当你使用require的时候，你会很自然地发现代码依赖关系处理以后不再是个头疼的问题，相反，我们可以很轻松地管理我们的代码。我们也可以通过NODE的打包工具将这些代码都打包起来用于前端统一输出以减少请求量。</p>
            <p>require方法分<code>window.require</code>和<code>module.require</code>两种</p>
            <h4><i class="fa fa-code"></i> window.require(deps, callback);</h4>
            <ul>
            	<li><strong>deps:</strong> 依赖关系数组</li>
                <li><strong>callback:</strong> 回调函数。回调函数的参与式更具deps参数的顺序来的。返回的是每个模块的对外接口。</li>
            </ul>
            <p>需要注意的是deps是一个路径选择器组成的数组。而callback可有可无。自然你也可以通过<code>.then()</code>方法来回调。比如下面的代码：</p>
            <pre>require('jquery').then(function(){
    return require(['./bootstrap/js/bootstrap.min.js', 'com-plugin-prettify']);
});</pre>
			<p>这个也可以称为页面级require。用来异步加载模块的。下面我们来讲模块级require：</p>
            <h4><i class="fa fa-code"></i> module.require(dep);</h4>
            <p>这个通常在define模块中直接写成<code>require('./a');</code>这种格式，在之前不用加module变量。</p>
            <ul>
            	<li><strong>dep:</strong> 需要被调用的模块的路径选择器</li>
            </ul>
            <p>它返回具体的模块的对外接口。</p>
            <pre>define(function(require, exports, module){
	return require('./a').constrcutor;
});</pre>
        </section>
        
        <section>
        	<h2><i class="fa fa-h-square"></i> define 定义模块</h2>
            <p>虽然此加载器都能加载默认的JS文档，但是推荐的做法是将这些文档都用define包裹起来。这样可以有效控制变量的作用域。define参数有3个参数，这3个参数位置不分先后。如果是function类型，那么就是define的主体函数。如果是boolean类型，那么就是模块依赖关系的AMD模式。如果是字符串或者数组类型，那么就是它的依赖关系的集合。这个看下实例就明白了。</p>
            <p>但是我需要说明的是define主体函数的参数。<code>factory(require, exports, module);</code></p>
            <ul>
            	<li><strong>require:</strong> 这个就是上面说明的module.require方法，是模块的基本加载方法。常用。</li>
                <li><strong>exports:</strong> 这个是JSON格式数据，是模块对外提供的接口。但是如果你的模块主体函数有return具体对象，那么exports就是这个具体对象。</li>
                <li><strong>module:</strong> 这个是模块的基本信息集合。可以输出出来查看下，这里就不做解释了。</li>
            </ul>
            <p>下面我们来看一个实例。</p>
            <pre>define('./c', true, function(require, exports, module){
	var a = new Class();
	a.add('a', function(){
		return 1;
	});
	
	a.extend(require('./b'));
	
	return a;
});</pre>
			<p>你也可以省略出主题函数外的任意一个或者2个参数。</p>
            <pre>define(function(require, exports, module){
	var b = new Class();
	b.add('b', function(){
		return 2;
	});
	b.extend(require('./c'));
	return b;
});</pre>
			<p>define也可以作为模块的配置，可以这样写。</p>
            <pre>define([
	'./prettify.css',
	'./prettify.js'
], true);</pre>
			<p>或者你连<code>true</code>都不要了也可以。</p>
            <p>总之，define的写法很灵活，随便你们怎么写。</p>
        </section>
        
        <section>
        	<h2><i class="fa fa-h-square"></i> 兴趣招募</h2>
            <p>如果你们对这套框架感兴趣，那么你们可以联系我，共同完善这套框架。</p>
            <p>QQ: 8802430</p>
            <p>Mail: evio@vip.qq.com</p>
        </section>
        
        <p>最后向所有来到本站的志同道合的朋友表示非常感谢。对使用本框架的同学表示衷心的欣慰。</p>
    </div>
    <div class="container">
    	<div class="clearfix" style="padding:30px 0px; color:#999; font-size:12px;">
        	<div class="pull-left"><i class="fa fa-copyright"></i> 2014 - 2015 Webkits.cN All Rights Reserved.</div>
            <div class="pull-right"><a href="http://app.webkits.cn" target="_blank"><i class="fa fa-pinterest"></i> Base on Pjblog5</a></div>
        </div>
    </div>
    <script src="http://tron.webkits.cn/tron.min.js"></script>
    <script src="http://tron.webkits.cn/tron.maps.js"></script>
    <script language="javascript">
		require('jquery').then(function(){
			return require(['./bootstrap/js/bootstrap.min.js', 'com-plugin-prettify']);
		});
	</script>
  </body>
</html>